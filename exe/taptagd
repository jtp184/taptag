#!/usr/bin/env ruby
require 'taptag'
require 'taptag/nfc'
require 'drb/drb'

module Taptag
  class RemoteDaemon
    ACTIONS = %w[start stop pid active].freeze
    PID_FOLDER = "/run/user/#{`id`.split(/\s+/).map { |s| s.scan(/(\w+)/) }.flatten[1]}".freeze
    PID_FILE_NAME = 'taptagd.pid'.freeze
    PID_FILE_PATH = "#{PID_FOLDER}/#{PID_FILE_NAME}".freeze

    class << self
      def start(args = {})
        if File.exist?(PID_FILE_PATH)
          puts 'Already running' and exit
        else
          daemonize
        end

        DRb.start_service(args[:uri] || 'druby://0.0.0.0:8787', Taptag::NFC)
        DRb.thread.join
      end

      def stop
        prid = File.read(PID_FILE_PATH).to_i

        Process.kill('TERM', prid)
        puts 'Stopped'
      end

      def pid
        puts File.read(PID_FILE_PATH)
      end

      def active
        puts File.exist?(PID_FILE_PATH)
      end

      private

      def daemonize
        exit if fork
        Process.setsid
        exit if fork

        Dir.chdir '/'
        redirect_output
        write_pidfile
      end

      def redirect_output
        $stderr.reopen('/dev/null', 'a')
        $stdout.reopen($stderr)
      end

      def write_pidfile
        File.open(PID_FILE_PATH, 'w+') { |f| f << DRb.thread.pid }
      end

      def remove_pidfile
        FileUtils.rm_f(PID_FILE_PATH)
      end
    end
  end
end

puts 'No command given' unless ARGV[0]

Taptag::RemoteDaemon.public_send(ARGV[0].to_sym)
